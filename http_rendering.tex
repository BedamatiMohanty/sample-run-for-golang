\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{occi}
\setlength{\headheight}{13pt}
\pagestyle{fancy}

% default sans-serif
\renewcommand{\familydefault}{\sfdefault}

% no lines for headers and footers
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% header
\fancyhf{}
\lhead{GWD-R}
\rhead{\today}

% footer
\lfoot{occi-wg@ogf.org}
\rfoot{\thepage}

% paragraphs need some space...
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

% some space between header and text...
\headsep 13pt

\setcounter{secnumdepth}{4}

% comments, temp stuff
\newcommand{\ralf}[1]{\textcolor{red}{Ralf: #1}}

\begin{document}

% header on first page is different
\thispagestyle{empty}

GWD-R \hfill Thijs Metsch, Platform Computing\\
OCCI-WG \hfill Andy Edmonds, Intel\\
\rightline {October 7, 2010}\\
\rightline {Updated: \today}

\vspace*{0.5in}

\begin{Large}
\textbf{Open Cloud Computing Interface - RESTful HTTP Rendering}
\end{Large}

\vspace*{0.5in}

\underline{Status of this Document}

This document provides information to the community regarding the
specification of the Open Cloud Computing Interface. Distribution is
unlimited.

\underline{Copyright Notice}

Copyright \copyright Open Grid Forum (2009-2010). All Rights Reserved.

\underline{Trademarks}

OCCI is a trademark of the Open Grid Forum.

\underline{Abstract}

This document, part of a document series, produced by the OCCI working
group within the Open Grid Forum (OGF), provides a high-level
definition of a Protocol and API. The document is based upon
previously gathered requirements and focuses on the scope of important
capabilities required to support modern service offerings.

\underline{Open comments}

\textbf{I think we need a section explicitly describing the mapping of OCCI Core
to OCCI HTTP rendering.  After all, an OCCI rendering describes "how to
interact with the OCCI Core model". This section should describe:
\begin{itemize}
\item The flat names-pace used in Core, i.e. just a bunch of IDs (Entity.id).
\item The hierarchical names-pace of RESTful HTTP (very brief).
\item How the hierarchical HTTP names-pace is mapped into the OCCI Core
names-pace.  (This is the important stuff.)
\end{itemize}
}
\textbf{ABNF form for syntax of HTTP X-OCCI-Loc, X-OCCI-Attr, HTTP Link and HTTP Category}

\textbf{Mention dives between HTTP 200 / 202 return types...}

\textbf{Mention the following: A kind, cate and mixin is rendered through HTTP category...}

\newpage
\tableofcontents
\newpage

\section{Introduction}
\input{include/introduction}

\section{Notational Conventions}
\input{include/notational}

All examples in this document use one of the following three HTTP
category definitions. An example namespace hierarchy is also
given. Syntax and Semantics is explained in the remaining sections of
the document. These examples do not strive to be complete but to show
the functionalities OCCI has:

\begin{verbatim}

Category: compute;
          scheme=http://schemas.ogf.org/occi/infrastructure;
          location=/compute 
    (This is an compute kind)

Category: storage;
          scheme=http://schemas.ogf.org/occi/infrastructure;
          location=/storage 
    (This is an storage kind)

Category: my_stuff;
          scheme=http://example.com/occi/my_stuff;
          location=/my_stuff 
    (This is a mixin of user1)

The following namespace hierarchy is used in the examples:

http://example.com/-/
http://example.com/vms/user1/vm1
http://example.com/vms/user1/vm2
http://example.com/vms/user2/vm1
http://example.com/disks/user1/disk1
http://example.com/disks/user2/disk1
http://example.com/compute/
http://example.com/storage/
http://example.com/my_stuff/
\end{verbatim}

The following notations are used when referring to parts or complete
URIs:

\begin{verbatim}
http://www.example.com:8080/foo/bar?action=stop
<   >  <     Authority    >< Path >< Fragment >
  ^
  Scheme
\end{verbatim}

All examples in this document use the \emph{text/plain} HTTP
Content-Type for posting information. To retrieve information the HTTP
Accept header \emph{text/plain} is used.

This specification is aligned with RFC 2986 \cite{rfc3986}.

\section{A RESTful HTTP Rendering for OCCI}
The HTTP Protocol is the underlying core fabric of OCCI and OCCI uses
all the features of the HTTP and underlying protocols offer. OCCI also
builds upon the Resource Oriented Architecture (ROA). ROA's use
Representation State Transfer (REST) \cite{REST_Fielding} to cater for
client and service interactions. Interaction with the system is by
inspection and modification of a set of related resources and their
states, be it on the complete state or a sub-set. Resources MUST be
uniquely identified. HTTP is an ideal protocol to use in ROA systems
as it provides the means to uniquely identify individual resources
through URLs as well as operating upon them with a set of
general-purpose methods known as HTTP verbs. These HTTP verbs map
loosely to the resource related operations of Create (POST), Retrieve
(GET), Update (POST/PUT) and Delete (DELETE).

The following section describe the general behaviour for all HTTP
based renderings. Later sections will describe the syntax and semantic
of how to render the OCCI Core model.

Each resource instance within an OCCI system must be uniquely
identified by an URI \cite{occi:core}. The structure of these URIs is
opaque and the system should not assume a static, pre-determined
scheme for their structure (Example \emph{Entity::id} can be:
\emph{http://example.com/vms/user1/vm1}).

\subsection{Behaviour of the HTTP Verbs}
As OCCI adopts a ROA, REST-based architecture and uses HTTP as the
foundation protocol the means of interaction with all RESTful resource
instances is through the four main HTTP verbs. OCCI service
implementations MUST, at a minimum, support these verbs as shown in
Table \ref{tbl:http_verbs}:

\mytablefloat{\label{tbl:http_verbs}HTTP Verb Behaviour}{
\begin{tabular}{p{1in} p{0.7in} p{0.7in} p{0.7in} p{0.7in} p{0.7in} p{0.7in}}
\toprule
Type & GET & POST (create) & POST (action) & PUT (create) & PUT (update) & DELETE \\
\colrule
resource instance & 
Rendering of this resource instance & 
Create a new resource instance & 
Trigger action & 
Create an resource instance at the given path & 
Update an resource instance at an given path & 
Delete this resource instance \\
\colrule
Path in the namespace hierarchy ending with / &	
Listing of all resource instances below this namespace & 
Create a new resource instance & 
N/A & 
N/A & 
N/A & 
Delete all the resource instances below this namespace hierarchy \\
\colrule
Location of an \hl{Mixin} or \hl{Kind} & 
Listing containing locations to all resource instances belonging to this \hl{Mixin} or \hl{Kind} & 
N/A & 
Trigger action (defined for this kind or mixin) on all resource instances belonging to this \hl{Mixin} or \hl{Kind} & 
Add an resource instance to a \hl{Mixin} & 
N/A & 
Remove an resource instance given in the request from a \hl{Mixin} \\
\colrule
Query Interface	& 
Listing of all registered \hl{Kind}s and \hl{Mixin}s & 
N/A & 
N/A & 
Add a user defined \hl{Mixin} & 
N/A & 
Remove a user-defined \hl{Mixin} (defined in the request) \\
\botrule
\end{tabular}
}

\subsection{A RESTful Rendering of OCCI}
The following sections and paragraphs describe how the OCCI model MUST
be implemented by OCCI implementations. Operations which are not
defined are out of scope for this specification and MAY be implemented
. This is the minimal set to ensure interoperability.

\subsubsection{Namespace Hierarchy and Location}
The namespace and the hierarchy are free definable by the Service
Provider. The OCCI implementation needs to implement the location path
feature, which is required by OCCI for discovering capabilities and
operations on \hl{Mixin}s and \hl{Kind}s. Location paths tell the
client where all resource instance of one \hl{Kind} or \hl{Mixin} can
be found regardless of the hierarchy the service provider
defines. These paths are discoverable by the client through the Query
interface \ref{sec:query}.

These location paths can be part of the namespace or rendered
alongside. The following example shows how the locations paths are
rendered alongside the namespace hierarchy. This means that the
locations paths defined by \hl{Kind}s or \hl{Mixin}s are not part of
the hierarchy of the REST Resources.

\begin{verbatim}
Category: compute;
          scheme=http://schemas.ogf.org/occi/infrastructure;
          location=/compute 
    (This is an compute kind)

Category: storage;
          scheme=http://schemas.ogf.org/occi/infrastructure;
          location=/storage 
    (This is an storage kind)

Category: my_stuff;
          scheme=http://example.com/occi/my_stuff;
          location=/my_stuff 
    (This is a mixin of user1)

The following namespace hierarchy is used in the examples:

http://example.com/-/
http://example.com/vms/user1/vm1
http://example.com/vms/user1/vm2
http://example.com/vms/user2/vm1
http://example.com/disks/user1/disk1
http://example.com/disks/user2/disk1
http://example.com/compute/
http://example.com/storage/
http://example.com/my_stuff/
\end{verbatim}

Location paths can also be part of the namespace hierarchy. In this
case the location is embedded in the hierarchy of resources (e.g. the location
of the compute \hl{Kind} is part of
http://example.com/vms/user1/vm1).

\begin{verbatim}
Category: compute;
          scheme=http://schemas.ogf.org/occi/infrastructure;
          location=/vms 
    (This is an compute kind)

Category: storage;
          scheme=http://schemas.ogf.org/occi/infrastructure;
          location=/disks 
    (This is an storage kind)

Category: my_stuff;
          scheme=http://example.com/occi/my_stuff;
          location=/my_stuff 
    (This is a mixin of user1)

The following namespace hierarchy is used in the examples:

http://example.com/-/
http://example.com/vms/user1/vm1
http://example.com/vms/user1/vm2
http://example.com/vms/user2/vm1
http://example.com/disks/user1/disk1
http://example.com/disks/user2/disk1
http://example.com/my_stuff/
\end{verbatim}

\subsubsection{Various Operations and their Prerequisites and Behaviours}

\paragraph{Operations on Resource Instances}
The following operations MUST be implemented by the OCCI
implementation for operations on resource instances. The resource
instance is uniquely identified by an URI (For example:
\emph{http://example.com/vms/user1/vm1}).\footnote{The path MUST not
  end with an '/' - that would mean that a client operates on a path
  in the namespace hierarchy}

\begin{description}
\item[Creating a resource instance] A request to create a resource
  instance MUST contain at least one HTTP category rendering which is
  (or relates to) a \hl{Kind} definition. If multiple HTTP categories
  are defined the first one which is (or relates to) to a \hl{Kind}
  MUST be used for defining the type of the resource
  instance. Optional information which might be provided by the client
  and if available MUST be used are HTTP Links and HTTP
  X-OCCI-Attributes (mapping to \hl{Link} and the attribtues of an
  resource instance). Two ways can be used to create a new resource
  instance - HTTP POST or PUT:
\begin{verbatim}
> POST / HTTP/1.1
> [...]
> 
> Category:compute;scheme=http://schemas.ogf.org/occi/infrastructure
> X-OCCI-Attribute:occi.compute.cores=2 occi.compute.hostname=foobar
> [...]
 
< HTTP/1.1 200 OK
< [...]
< Location:http://example.com/vms/user1/vm1
\end{verbatim}
  The path on which this POST verb is executed can be any existing
  path in the hierarchy of the Service provider's namespace. The OCCI
  implementation MUST return the Location of the newly created
  resource instance.

  HTTP PUT can also be used to create a resource instance. In this
  case the client ask the service provider to create a resource
  instance at a certain path in the namespace hierarchy.\footnote{If a
    Service Provider does not want the user to define the path of a
    resource instance it can return a Bad Request return code - See
    section \ref{sec:return_codes}. Service Providers MUST ensure that
    the paths of REST resources stays unique in their namespace.}
\begin{verbatim}
> PUT /vms/user1/my_first_virtual_machine HTTP/1.1
> [...]
> 
> Category:compute;scheme=http://schemas.ogf.org/occi/infrastructure
> X-OCCI-Attribute:occi.compute.cores=2 occi.compute.hostname=foobar
> [...]
 
< HTTP/1.1 200 OK
< [...]
\end{verbatim}
  The OCCI implementation will return an OK code.

\item[Retrieving a resource instance] For retrieval the HTTP GET verb
  is used. It MUST return at least the HTTP category which defines the
  \hl{Kind} of the resource instance. HTTP Links pointing to related
  resource instances, other URI or Actions MUST be included if
  present. Only Actions currently applicatble SHOULD be rendered using
  HTTP Links. The Attributes of the resource instance MUST be exposed
  to the client if available.
\begin{verbatim}
> GET /vms/user1/vm1 HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
< Category:compute;scheme=http://schemas.ogf.org/occi/infrastructure
< Category:my_stuff;scheme=http://example.com/occi/my_stuff
< X-OCCI-Attribute:occi.compute.cores=2 occi.compute.hostname=foobar
< Link: [...]
\end{verbatim}

\item[Updating a resource instance] Before updating a resource
  instance it is RECOMMENDED that the client first retrieves the
  resource instance. Updating is done using the HTTP PUT verb. Only
  the information (HTTP Links, HTTP X-OCCI-Attributes or HTTP
  categories), which are updated MUST be provided along with the
  request.\footnote{Changing the type of the resource instance MUST
    not be possible.}
\begin{verbatim}
> PUT /vms/user1/vm1 HTTP/1.1
> [...]
> 
> X-OCCI-Attribute: occi.compute.memory=4.0
> [...]
 
< HTTP/1.1 200 OK
< [...]
\end{verbatim}

\item[Deleting a resource instance] A resource instance can be deleted
  using the HTTP DELETE verb. No other information SHOULD be added to
  the request.\footnote{If the resource instances is a \hl{Link} type
    the source and target must be updated accordingly}
\begin{verbatim}
> DELETE /vms/user1/vm1 HTTP/1.1
> [...]

< HTTP/1.1 200 OK
< [...]
\end{verbatim}

\item[Triggering an Action on a resource instance] To trigger an
  action on a resource instance the request MUST containing the HTTP
  Category defining the \hl{Action}. It MAY include HTTP
  X-OCCI-Attributes which are the parameters of the action. Actions
  are triggered using the HTTP POST verb and by adding a fragment to
  the URI. This fragment exposes the term of the \hl{Action}. If an
  action is not available a Bad Request should be returned.
\begin{verbatim}
> POST /vms/user1/vm1?action=stop HTTP/1.1
> [...]
> Category: TBD...
> X-OCCI-Attribute:method=poweroff

< HTTP/1.1 200 OK
< [...]
\end{verbatim}
\end{description}

\paragraph{Handling the Query Interface}
\label{sec:query}
The query interface MUST be implemented by all OCCI
implementations. It MUST be found at the path \emph{/-/} off the root
of the OCCI implementation. The following operations, listed below,
MUST be implemented by the service.

\begin{description}
\item[Retrieval of all registered \hl{Kind}s and \hl{Mixin}s] The HTTP
  verb GET must be used to retrieve al l\hl{Kind}s and \hl{Mixin}s the
  service can handle. This allows the client to discover the
  capabilities of the OCCI implementation. The result MUST contain all
  information about the \hl{Kind}s and \hl{Mixin}s (including
  Attributes and \hl{Actions} assigned).
\begin{verbatim}
> GET /-/ HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
< Category: compute;
            scheme=http://schemas.ogf.org/occi/infrastructure;
            attributes=occi.compute.cores,occi...;
            rel=http://schemas.ogf.org/occi/core\#entity;
            actions=http://schemas.ogf.org/occi/infrastructure/compute/action#stop,...;
            location=/compute;
< Category: my_stuff;
            scheme=http://example.com/occi/my_stuff;
            location=/my_stuff;
< Category: storage; 
            scheme=http://schemas.ogf.org/occi/infrastructure;
            attributes="...";
            actions="...";
            rel=http://schemas.ogf.org/occi/core\#entity;
            location=/storage;
 
\end{verbatim}
An OCCI implementation MUST support a filtering mechanism. If a HTTP
Category is provided in the request the server MUST only return the
complete rendering of the requested \hl{Kind} or \hl{Mixin}.

\item[Adding a \hl{Mixin} definition] To add a \hl{Mixin} to
  the service the HTTP PUT verb MUST be used. All possible information
  for the \hl{Mixin} must be defined. At least the HTTP Category term,
  scheme and location MUST be defined. Actions and Attributes are not
  supported:
\begin{verbatim}
> GET /-/ HTTP/1.1
> [...]
> Category: my_stuff;
            scheme=http://example.com/occi/my_stuff;
            rel=http:/example.com/occi/something_else#mixin;
            location=/my_stuff;

< HTTP/1.1 200 OK
< [...]
\end{verbatim}
The service might reject this request if it does not allow
user-defined \hl{Mixin}s to be created. Also on name collisions of the
defined location path the service provider might reject this
operation.

\item[Removing a \hl{Mixin} definition] A user defined
  \hl{Mixin} CAN be removed (if allowed) by using the HTTP DELETE
  verb. The information about which \hl{Mixin} should be deleted MUST
  be provided in the request:
\begin{verbatim}
> DELETE /-/ HTTP/1.1
> [...]
> Category: my_stuff;scheme=http://example.com/occi/my_stuff;

< HTTP/1.1 200 OK
< [...]
\end{verbatim}
\end{description}

\paragraph{Operations on \hl{Mixin}s or \hl{Kind}s}
All the following operations CAN only be be done on a location paths
provided by \hl{Kind}s and \hl{Mixin}s. It MUST end with an
\emph{/}.

\begin{description}
\item[Retrieving All Resource Instances Belonging to \hl{Mixin} or
  \hl{Kind}] The HTTP verb GET must be used to retrieve all resource
  instances. The service provider MUST return a listing containing
  all resource instances which belong to the requested \hl{Mixin} or
  \hl{Kind}:
\begin{verbatim}
> GET /compute/ HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
< 
< X-OCCI-Location: http://example.com/vms/user1/vm1
< X-OCCI-Location: http://example.com/vms/user1/vm2
< X-OCCI-Location: http://example.com/vms/user2/vm1
\end{verbatim}
\textbf{Note:} A OCCI implementation MUST support a filtering
mechanism. If a HTTP Category is provided in the request the server
MUST only return the resource instances belonging to the provided
\hl{Kind} or \hl{Mixin}. The provided HTTP category definition SHOULD
be different from the \hl{Kind} or \hl{Mixin} definition which defined
the location path used in the request.

\item[Triggering Actions on All Instances of a \hl{Mixin} or
  \hl{Kind}] Actions can be triggered on all resource instances of the
  same \hl{Mixin} or \hl{Kind}. The HTTP POST verb MUST be used. Also
  the Action MUST be defined by the \hl{Kind} or \hl{Mixin} which
  defines the location path which is used in the request:
\begin{verbatim}
> POST /compute/;action=stop HTTP/1.1
> [...]
 X-OCCI-Attribute:method=poweroff

< HTTP/1.1 200 OK
< [...]
\end{verbatim}

\item[Associate resource instances with \hl{Mixin}s] One
  or multiple resource instances can be associated with a \hl{Mixin}
  using the HTTP PUT verb. The URIs which uniquely defined the
  resource instance MUST be provided in the request:
\begin{verbatim}
> PUT /my_stuff/ HTTP/1.1
> [...]
> X-OCCI-Location:http://example.com/vms/user1/vm1,
                  http://example.com/vms/user1/vm2,
                  http://example.com/disks/user1/disk1

< HTTP/1.1 200 OK
< [...]
\end{verbatim}

\item[Unassociate resource instance(s) from a \hl{Mixin}] One or multiple
  resource instances can be removed from a \hl{Mixin} using the HTTP
  DELETE verb. The URIs which uniquely defined the resource instance
  MUST be provided in the request:
\begin{verbatim}
> DELETE /my_stuff/ HTTP/1.1
> [...]
> X-OCCI-Location:http://example.com/vms/user1/vm1,
                  http://example.com/vms/user1/vm2,
                  http://example.com/disks/user1/disk1

< HTTP/1.1 200 OK
< [...]
\end{verbatim}
\end{description}

\paragraph{Operation on Paths in the Namespace}
The following operations are defined when operating on paths in the
namespace hierarchy which are not location paths nor resource
instances. They MUST end with \emph{/} (For example
\emph{http://example.com/vms/user1}).

\begin{description}
\item[Retrieving All resource instances Below a Path] The HTTP verb
  GET must be used to retrieve all resource instances. The service
  provider MUST return a Listing containing all resource instances
  which are children of the provided URI in the namespace hierarchy:
\begin{verbatim}
> GET /vms/user1/ HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
< 
< X-OCCI-Location: http://example.com/vms/user1/vm1
< X-OCCI-Location: http://example.com/vms/user1/vm2
\end{verbatim}
An OCCI implementationx MUST support a filtering mechanism. If a
category is provided in the request the server MUST only return the
resource instances belonging to the provided \hl{Mixin} or \hl{Kind}.

\item[Deletion of all resource instances below a path] \textbf{(Note:
  this is a potentially dangerous operation!)} The HTTP verb DELETE
  must be used to delete all resource instances under a hierarchy:
\begin{verbatim}
> DELETE /vms/user1/ HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
\end{verbatim}
\end{description}

\subsection{Syntax and Semantics of the Rendering}
\label{sec:syntax}

\subsubsection{Rendering of an OCCI-Category}
The semantics of the HTTP category in the OCCI context is described in the
OCCI Core \& Models document. This rendering follows the
  Category header defined by the Web Categories specification
  \footnote{http://tools.ietf.org/html/draft-johnston-http-category-header-01} 
  and MUST be rendered accordingly.

\begin{verbatim}
Category: <term>; scheme="<scheme>"
    [;rel=<space-separated list of related Category identifiers>]
    [;attributes=<space-seperated list of attribute names>]
    [;title=<Title of this Category>]    
    [;location=<Parent location>]
\end{verbatim}
There is NO order for the optional part \textbf{(Andy: What 'optional' part?)}.

\subsubsection{Rendering of OCCI-Links and OCCI-Actions}
The semantics of the HTTP Link header in the OCCI context is described in
the OCCI Core \& Models document. This rendering follows the
  Link header defined by the Web Linking specification
  \footnote{http://tools.ietf.org/html/draft-nottingham-http-link-header-10} and
  MUST be rendered accordingly.

\begin{verbatim}
Link: <Resource URL>;
    rel=<space-separated list of Category identifiers of the target Resource type>
    [;self=<Link instance URL>]
    [;category=<space-separated list of Category identifiers of the Link type>
    [;<attribute name>=<attribute value>] ... ]

or in case it is an Action:

Link: <Resource URL> + ";action=" + <Term of the Action>;
    rel=<Category identifier of the Action>
\end{verbatim}

\subsubsection{Rendering of OCCI-Attributes}
The X-OCCI-Attribute MUST be used to render the attributes associated
with a OCCI Kind. A simple key-value format is used. The field value
consist of an attribute name followed by an equal sign ("=") and the
attribute value. The attribute value must be double quoted if it
includes a separator character, see RFC 2616 (page 16).

\begin{verbatim}
X-OCCI-Attribute: <attribute name>=<attribute value>
\end{verbatim}

Valid attribute names for OCCI Kinds are specified in appropriate
Extension documents \ref{occi:infrastructure}.

\subsubsection{Rendering of Location-URLs}
To render an OCCI representation solely in the header, the
X-OCCI-Location HTTP header MUST be used to return a list of Kind
URLs. Each header field value correspond to a single URL. Multiple
Kind URLs are returned using multiple X-OCCI-Location headers. See RFC
2616 for information on how to render multiple HTTP headers.

\begin{verbatim}
X-OCCI-Location: <URL>
\end{verbatim}

%\subsubsection{Fields}
%\textbf{(Andy: a little unclear - maybe add 'the required HTTP headers are
% those needed at a minimum to represent the particular OCCI core model entity')}
%\ralf{I like this table, having a clear overview of which HTTP Header is used
%to render a particular OCCI type/instance is very good in my opinion. Table need
%to be updated though.}
%The following setups show how the Core Model MUST be rendered. Shown
%are the fields which MUST be available in a request from the Client or
%a response from the Server.
%\begin{tabular}{l|l|l|l}
%Operation & Required HTTP-Header(s) & Optional HTTP-Header(s) & Notes \\
%\hline
%Rendering of a Category instance & Category & N/A & \\
%Rendering of a Kind instance & Category & N/A & \\
%Rendering of a Mixin instance & Category & N/A & \\
%Rendering a list of Category, Kind and Mixin instances & Category & N/A & \\
%Rendering a list of Entity sub-type instances & X-OCCI-Location & N/A & \\
%Rendering of a Resource & Category & X-OCCI-Attribute, Link & \\
%Rendering of an Action & Category, Link & X-OCCI-Attribute & \\
%Rendering of a Link & Category, Link & X-OCCI-Attribute & \\
%\end{tabular}

\subsection{General HTTP Behaviour Adopted by OCCI}
The following sections deal with some general HTTP features which are
adopted by OCCI.

\subsubsection{Caching}
\textbf{(Andy: If this is general in respect to OCCI and in the context of HTTP then
we should include the use of caching-related headers)}

\subsubsection{Security and Authentication}
OCCI does not require that an authentication mechanism be used nor
does it require that client to service communications are secured. It
does recommend that an authentication mechanism be used and that where
appropriate, communications are encrypted using HTTP over TLS. The
authentication mechanisms that CAN be used with OCCI are those that
can be used with HTTP and TLS.

\subsubsection{Versioning}
Information about what version of OCCI is supported by a OCCI
implementation MUST be advertised to a client on each response to a
client. The version field in the response MUST include the value
OCCI/X.Y, where X is the major version number and Y is the minor
version number of the implemented OCCI specification. In the case of a
HTTP Header Rendering, the server response MUST relay versioning
information using the HTTP header name 'Server'.

\begin{verbatim}
HTTP/1.1 202 Accepted
Server: occi-server/1.1 (linux) OCCI/1.1
[...]
\end{verbatim}

Complimenting the service-side behaviour of an OCCI implementation, a
client SHOULD indicate to the OCCI service implementation the version
it expects to interact with. For the clients, the information SHOULD
be advertised in all requests it issues. A client request SHOULD
relay versioning information in the 'User-Agent' header. The
'User-Agent' field MUST include the same value (OCCI/X.Y) as supported
by the Server HTTP header.

\begin{verbatim}
GET <Path> HTTP/1.1
Host: example.com
User-Agent: occi-client/1.1 (linux) libcurl/7.19.4 OCCI/1.1
[...]
\end{verbatim}

If a OCCI implementation receives a request from a client that
supplies a version number higher than the service supports, the
service MUST respond back to the client with an exception indicating
that the requested version is not implemented. Where a client
implements OCCI using a HTTP transport, the HTTP code 501, not
implemented, MUST be used.

OCCI implementations which implement this version of the Document MUST
use the version String \emph{OCCI/1.1}.

\subsubsection{Content-type and Accept headers}
A server MUST react according to the Accept header the client
provides. If none is given - or \textit{*/*} is used - the service MUST
use the Content-type \emph{text/plain}. This is the fall-back
rendering and MUST be implemented. Otherwise the according rendering
MUST be used. Each Rendering SHOULD expose which Accept and
Content-type header fields it can handle. Overall the service MUST
support the \textit{text/occi} and \textit{text/plain} Content-types.

The server MUST also return the proper Content-type header. If a
client provides information with a Content-Type - the information MUST
be parsed accordingly.

When the Client request a Content-Type that will result in an
incomplete or faulty rendering the Service MUST return the unsupported
media type , 415, HTTP code.

The following examples demonstrate the behaviour of an HTTP GET
operations on the resource instance \emph{} using two different HTTP
Accept headers:

\begin{verbatim}
> GET /vms/user1/vm1 HTTP/1.1
> Accept: text/plain
> [...]
 
< HTTP/1.1 200 OK
< [...]
< Category:compute;scheme=http://schemas.ogf.org/occi/infrastructure
< Category:my_stuff;scheme=http://example.com/occi/my_stuff
< X-OCCI-Attribute:occi.compute.cores=2 occi.compute.hostname=foobar
< Link: [...]
\end{verbatim}

And with \emph{text/occi} as HTTP Accept header:

\begin{verbatim}
> GET /vms/user1/vm1 HTTP/1.1
> Accept: text/occi
> [...]
 
< HTTP/1.1 200 OK
< Category:compute;scheme=http://schemas.ogf.org/occi/infrastructure
< Category:my_stuff;scheme=http://example.com/occi/my_stuff
< X-OCCI-Attribute:occi.compute.cores=2 occi.compute.hostname=foobar
< Link: [...]
< [...]
OK
\end{verbatim}

\paragraph{The Content-type text/plain}
While using this rendering with the Content-Type \textit{text/plain}
the information described in section \ref{sec:syntax} MUST be placed
in the HTTP Body.

Each rendering of an OCCI base type will be placed in the body. Each
entry consists of a name followed by a colon (":") and the field
value. The format of the field value is specified separately for each
of the three header fields, see section \ref{sec:syntax}.

\paragraph{The Content-type text/occi}
While using this rendering with the Content-Type \textit{text/occi}
the information described in section \ref{sec:syntax} MUST be placed
in the HTTP Header. The body MUST contain the string 'OK' on
successful operations.

The HTTP header fields MUST follow the specification in RFC 2616
\cite{rfc2616}. A header field consists of a name followed by a colon
(":") and the field value. The format of the field value is specified
separately for each of the header fields, see section
\ref{sec:syntax}.

\textbf{Limitations: } HTTP header fields MAY appear multiple times in
a HTTP request or response. In order to be OCCI compliant the
specification of multiple message-header fields according to RFC 2616
MUST be fully supported. In essence there are two valid representation
of multiple HTTP header field values. A header field might either
appear several times or as a single header field with a
comma-separated list of field values. Due to implementation issues in
many web frameworks and client libraries it is RECOMMENDED to use the
comma-separated list format for best interoperability.

HTTP header field values which contain separator characters MUST be
properly quoted according to RFC 2616.

Space in the HTTP header section of a HTTP request is a limited
resource. By this, it is noted that many HTTP servers limit the number
of bytes that can be placed in the HTTP Header area. Implementers MUST
be aware of this limitation in their own implementation and take
appropriate measures so that truncation of header data does NOT
occur.

\paragraph{The Content-type text/uri-list}
This Rendering can handle the \textit{text/uri-list} Accept Header. It
will use the Content-type \textit{text/uri-list}.

This rendering cannot render resource instances or \hl{Kind}s or
\hl{Mixin}s directly but just links to them. For concrete rendering of
Kinds and Categories the Content-types \textit{text/occi},
\textit{text/plain} MUST be used. If a request is done with the
\textit{text/uri-list} in the Accept header, while not requesting for
a Listing a Bad Request MUST be returned.

\subsubsection{Return codes}
\label{sec:return_codes}
At any point the service provider CAN return any of the following HTTP
Return Codes:

\mytablefloat{\label{tbl:http_codes}HTTP Return Codes}{
\begin{tabular}{l|l|p{3in}}
\toprule
Code & Description & Notes \\
\colrule
200 & OK & \\
202 & Accepted & For example when creating a Virtual machine the operation can take a while. \\
400 & Bad Request & For example on parsing errors or missing information \\
401 & Unauthorized & \\
403 & Forbidden & \\
405 & Method Not Allowed & \\
409 & Conflict & \\
410 & Gone & \\
415 & Unsupported Media Type & \\
500 & Internal Server Error & \\
501 & Not Implemented & \\
503 & Service Unavailable & \\
\botrule
\end{tabular}}

\subsection{More complete examples}
Since most examples are not complete due to space limitations this
section will give some more complete examples.

\subsubsection{Creating a resource instance}
\begin{verbatim}
* About to connect() to localhost port 8080 (#0)
*   Trying ::1... Connection refused
*   Trying 127.0.0.1... connected
* Connected to localhost (127.0.0.1) port 8080 (#0)
> POST / HTTP/1.1
> User-Agent: curl/7.21.0 (x86_64-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
> Host: localhost:8080
> Accept: */*
> Content-Type: text/occi
> Category: compute;scheme=http://schemas.ogf.org/occi/infrastructure
> 
< HTTP/1.1 200 OK
< Content-Length: 2
< Content-Type: text/html; charset=UTF-8
< Location: /users/default/compute/940feba9-1fdf-4079-aab4-8e83f18c73e4
< Server: pyocci OCCI/1.1
< 
* Connection #0 to host localhost left intact
* Closing connection #0
OK%   
\end{verbatim}

\subsubsection{Retrieving a resource instance}
\begin{verbatim}
* About to connect() to localhost port 8080 (#0)
*   Trying ::1... Connection refused
*   Trying 127.0.0.1... connected
* Connected to localhost (127.0.0.1) port 8080 (#0)
> GET /users/default/compute/940feba9-1fdf-4079-aab4-8e83f18c73e4 HTTP/1.1
> User-Agent: curl/7.21.0 (x86_64-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
> Host: localhost:8080
> Accept: */*
> 
< HTTP/1.1 200 OK
< Content-Length: 68
< Etag: "7f8e453f1e002a66375a411a6b0ffa5e97877d8d"
< Content-Type: text/plain
< Server: pyocci OCCI/1.1
< 
Category: compute;scheme=http://schemas.ogf.org/occi/infrastructure
* Connection #0 to host localhost left intact
* Closing connection #0
\end{verbatim}

\section{Contributors}
\input{include/contributors}

\section{Glossary}
\label{sec:glossary}
\input{include/glossary}

\section{Intellectual Property Statement}
\input{include/ip}

\section{Disclaimer}
\input{include/disclaimer}

\section{Full Copyright Notice}
\input{include/copyright}

\section{References}

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
